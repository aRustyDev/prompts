---
name: todo-integration
description: Integrate with TODO systems for bidirectional sync of work items
version: 1.0.0
type: process
scope: temporary
conditional: true
---

# TODO Integration Process

## Purpose
Enable bidirectional synchronization between discovered work items and various TODO management systems. Auto-detect TODO systems, convert work items to TODOs, track progress, and update completion status.

## Supported TODO Systems

### Auto-Detection
```bash
# Detect available TODO systems
detect_todo_systems() {
  local systems=()
  
  # Claude TODO.md
  if [[ -f "TODO.md" ]] || [[ -f "${HOME}/.claude/TODO.md" ]]; then
    systems+=("claude")
  fi
  
  # todo.txt
  if [[ -f "${HOME}/todo.txt" ]] || [[ -f "${HOME}/Dropbox/todo.txt" ]]; then
    systems+=("todotxt")
  fi
  
  # Taskwarrior
  if command -v task &>/dev/null && [[ -d "${HOME}/.task" ]]; then
    systems+=("taskwarrior")
  fi
  
  # GitHub Projects (via gh CLI)
  if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
    systems+=("github")
  fi
  
  # Local JSON TODO file
  if [[ -f "${HOME}/.claude/todos.json" ]]; then
    systems+=("local")
  fi
  
  # Org-mode
  if [[ -f "${HOME}/org/todo.org" ]] || [[ -d "${HOME}/.emacs.d" ]]; then
    systems+=("orgmode")
  fi
  
  printf '%s\n' "${systems[@]}"
}

# Get primary TODO system
get_primary_todo_system() {
  local config_file="${HOME}/.claude/settings/todo-integration.yaml"
  
  if [[ -f "$config_file" ]]; then
    yq eval '.primary_system // "auto"' "$config_file"
  else
    # Auto-detect first available
    detect_todo_systems | head -1
  fi
}
```

### Claude TODO.md Integration
```bash
# Add work item to Claude TODO.md
add_to_claude_todo() {
  local item="$1"
  local todo_file="${2:-TODO.md}"
  
  # Create TODO.md if doesn't exist
  if [[ ! -f "$todo_file" ]]; then
    cat > "$todo_file" <<'EOF'
# TODO

## High Priority

## In Progress

## Planned

## Ideas

---
*Generated by Claude TODO Integration*
EOF
  fi
  
  # Format TODO entry
  local todo_entry=$(echo "$item" | jq -r '
    "- [ ] [\(.type | ascii_upcase) #\(.number)](\(.url)): \(.title)" +
    (if .labels then "\n  - Labels: \(.labels | join(", "))" else "" end) +
    (if .estimated_minutes then "\n  - Estimated: \(.estimated_minutes) minutes" else "" end) +
    (if .composite_score then "\n  - Priority Score: \(.composite_score | floor)" else "" end) +
    "\n  - Added: \(now | strftime("%Y-%m-%d"))"
  ')
  
  # Determine section based on priority
  local section=$(echo "$item" | jq -r '
    if .priority == "critical" or .priority == "high" then "## High Priority"
    elif .tags | any(. == "in-progress") then "## In Progress"
    else "## Planned"
    end
  ')
  
  # Insert into appropriate section
  awk -v section="$section" -v entry="$todo_entry" '
    $0 == section { print; print ""; print entry; next }
    { print }
  ' "$todo_file" > "${todo_file}.tmp" && mv "${todo_file}.tmp" "$todo_file"
  
  echo "‚úÖ Added to $todo_file"
}

# Update Claude TODO.md status
update_claude_todo_status() {
  local item_number="$1"
  local status="$2"  # completed, in-progress, cancelled
  local todo_file="${3:-TODO.md}"
  
  case "$status" in
    "completed")
      sed -i.bak "/#$item_number/s/\[ \]/[x]/" "$todo_file"
      ;;
    "in-progress")
      # Move to In Progress section
      local line=$(grep -n "#$item_number" "$todo_file" | cut -d: -f1)
      if [[ -n "$line" ]]; then
        sed -i.bak "${line}s/- \[ \]/- [~]/" "$todo_file"
      fi
      ;;
    "cancelled")
      sed -i.bak "/#$item_number/s/\[ \]/[-]/" "$todo_file"
      ;;
  esac
}
```

### todo.txt Integration
```bash
# Add to todo.txt format
add_to_todotxt() {
  local item="$1"
  local todo_file="${2:-${HOME}/todo.txt}"
  
  # Format according to todo.txt spec
  local todo_line=$(echo "$item" | jq -r '
    # Priority mapping
    (if .priority == "critical" then "(A)"
     elif .priority == "high" then "(B)"
     elif .priority == "medium" then "(C)"
     else "" end) as $pri |
    
    # Format tags
    (.labels // [] | map("+" + .) | join(" ")) as $tags |
    
    # Build todo line
    [
      $pri,
      .title,
      $tags,
      "@work",
      "issue:" + (.number | tostring),
      "url:" + .url
    ] | join(" ")
  ')
  
  # Append to todo.txt
  echo "$todo_line" >> "$todo_file"
  
  # Sort by priority if todo.txt tools available
  if command -v todo.sh &>/dev/null; then
    todo.sh sort
  fi
}

# Parse todo.txt for work items
parse_todotxt_work() {
  local todo_file="${1:-${HOME}/todo.txt}"
  
  if [[ ! -f "$todo_file" ]]; then
    echo "[]"
    return
  fi
  
  # Extract work-related todos
  grep -E "@work|issue:|pr:" "$todo_file" | \
  awk '{
    # Extract priority
    priority = "normal"
    if (match($0, /^\([A-Z]\)/)) {
      pri = substr($0, 2, 1)
      if (pri == "A") priority = "critical"
      else if (pri == "B") priority = "high"
      else if (pri == "C") priority = "medium"
    }
    
    # Extract issue/PR number
    if (match($0, /issue:([0-9]+)/, m)) {
      number = m[1]
    } else if (match($0, /pr:([0-9]+)/, m)) {
      number = m[1]
    }
    
    # Extract URL
    if (match($0, /url:([^ ]+)/, m)) {
      url = m[1]
    }
    
    # Extract title (remove metadata)
    title = $0
    gsub(/^\([A-Z]\) /, "", title)
    gsub(/ (issue|pr|url):[^ ]+/, "", title)
    gsub(/ [@+][^ ]+/, "", title)
    
    if (number) {
      print "{\"number\": " number ", \"title\": \"" title "\", \"priority\": \"" priority "\", \"url\": \"" url "\"}"
    }
  }' | jq -s '.'
}
```

### Taskwarrior Integration
```bash
# Add to Taskwarrior
add_to_taskwarrior() {
  local item="$1"
  
  # Build task command
  local task_cmd="task add"
  
  # Description
  task_cmd="$task_cmd '$(echo "$item" | jq -r '
    "[\(.type | ascii_upcase) #\(.number)] \(.title)"
  ')'"
  
  # Priority
  local priority=$(echo "$item" | jq -r '
    if .priority == "critical" then "H"
    elif .priority == "high" then "M"
    elif .priority == "medium" then "L"
    else "" end
  ')
  [[ -n "$priority" ]] && task_cmd="$task_cmd priority:$priority"
  
  # Project
  task_cmd="$task_cmd project:work"
  
  # Tags
  echo "$item" | jq -r '.labels[]? // empty' | while read -r label; do
    task_cmd="$task_cmd +${label// /_}"
  done
  
  # Annotations
  task_cmd="$task_cmd"
  local task_id=$(eval "$task_cmd" | grep -oP 'Created task \K[0-9]+')
  
  # Add URL as annotation
  if [[ -n "$task_id" ]]; then
    task "$task_id" annotate "$(echo "$item" | jq -r .url)"
  fi
  
  echo "‚úÖ Added to Taskwarrior (ID: $task_id)"
}

# Sync Taskwarrior status
sync_taskwarrior_status() {
  # Get work-related tasks
  task project:work export | jq -r '
    .[] | select(.description | test("\\[(ISSUE|PR) #[0-9]+\\]")) |
    {
      uuid: .uuid,
      number: (.description | capture("\\[(ISSUE|PR) #(?<num>[0-9]+)\\]") | .num),
      status: .status,
      completed: .end
    }
  ' | while read -r task; do
    local number=$(echo "$task" | jq -r .number)
    local status=$(echo "$task" | jq -r .status)
    
    # Update work item status based on task status
    if [[ "$status" == "completed" ]]; then
      mark_work_item_complete "$number"
    fi
  done
}
```

### GitHub Projects Integration
```bash
# Add to GitHub Project
add_to_github_project() {
  local item="$1"
  local project_number="${2:-$(get_default_project_number)}"
  
  # Get project ID
  local project_id=$(gh api graphql -f query='
    query($owner: String!, $repo: String!, $number: Int!) {
      repository(owner: $owner, name: $repo) {
        projectV2(number: $number) {
          id
        }
      }
    }' -f owner="$GITHUB_OWNER" -f repo="$GITHUB_REPO" -f number="$project_number" \
    --jq '.data.repository.projectV2.id')
  
  # Add item to project
  local item_id=$(echo "$item" | jq -r '
    if .type == "issue" then "Issue"
    else "PullRequest"
    end + "_" + .node_id
  ')
  
  gh api graphql -f query='
    mutation($projectId: ID!, $contentId: ID!) {
      addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
        item {
          id
        }
      }
    }' -f projectId="$project_id" -f contentId="$item_id"
  
  echo "‚úÖ Added to GitHub Project #$project_number"
}

# Get items from GitHub Project
get_github_project_items() {
  local project_number="${1:-$(get_default_project_number)}"
  
  gh api graphql -f query='
    query($owner: String!, $repo: String!, $number: Int!) {
      repository(owner: $owner, name: $repo) {
        projectV2(number: $number) {
          items(first: 100) {
            nodes {
              content {
                ... on Issue {
                  number
                  title
                  state
                  labels(first: 10) {
                    nodes { name }
                  }
                }
                ... on PullRequest {
                  number
                  title
                  state
                  labels(first: 10) {
                    nodes { name }
                  }
                }
              }
            }
          }
        }
      }
    }' -f owner="$GITHUB_OWNER" -f repo="$GITHUB_REPO" -f number="$project_number" \
    --jq '.data.repository.projectV2.items.nodes[].content | 
      select(. != null) | {
        number,
        title,
        state,
        labels: .labels.nodes | map(.name)
      }'
}
```

### Local JSON TODO Integration
```bash
# Add to local JSON TODOs
add_to_local_todos() {
  local item="$1"
  local todos_file="${HOME}/.claude/todos.json"
  
  # Initialize file if needed
  if [[ ! -f "$todos_file" ]]; then
    mkdir -p "$(dirname "$todos_file")"
    echo '{"todos": [], "version": "1.0.0"}' > "$todos_file"
  fi
  
  # Create TODO entry
  local todo=$(echo "$item" | jq '{
    id: (now | tostring),
    created: (now | strftime("%Y-%m-%dT%H:%M:%SZ")),
    type: "work_item",
    work_item: {
      type: .type,
      number: .number,
      url: .url
    },
    title: .title,
    description: .description,
    priority: .priority,
    labels: .labels,
    status: "pending",
    estimated_minutes: .estimated_minutes,
    score: .composite_score
  }')
  
  # Add to todos
  jq --argjson todo "$todo" '.todos += [$todo]' "$todos_file" > "${todos_file}.tmp" && \
    mv "${todos_file}.tmp" "$todos_file"
  
  echo "‚úÖ Added to local TODOs"
}

# Update local TODO status
update_local_todo_status() {
  local todo_id="$1"
  local status="$2"
  local todos_file="${HOME}/.claude/todos.json"
  
  jq --arg id "$todo_id" --arg status "$status" '
    .todos |= map(
      if .id == $id then 
        .status = $status |
        .updated = (now | strftime("%Y-%m-%dT%H:%M:%SZ")) |
        if $status == "completed" then
          .completed = (now | strftime("%Y-%m-%dT%H:%M:%SZ"))
        else . end
      else . end
    )
  ' "$todos_file" > "${todos_file}.tmp" && \
    mv "${todos_file}.tmp" "$todos_file"
}
```

## Synchronization Functions

### Batch Add to TODO Systems
```bash
# Add multiple items to TODO systems
batch_add_to_todos() {
  local items="$1"
  local systems="${2:-auto}"
  
  # Determine target systems
  if [[ "$systems" == "auto" ]]; then
    systems=$(detect_todo_systems)
  fi
  
  local count=$(echo "$items" | jq 'length')
  echo "üìù Adding $count items to TODO systems: $systems"
  
  # Process each item
  echo "$items" | jq -c '.[]' | while read -r item; do
    for system in $systems; do
      case "$system" in
        "claude")
          add_to_claude_todo "$item"
          ;;
        "todotxt")
          add_to_todotxt "$item"
          ;;
        "taskwarrior")
          add_to_taskwarrior "$item"
          ;;
        "github")
          add_to_github_project "$item"
          ;;
        "local")
          add_to_local_todos "$item"
          ;;
      esac
    done
  done
  
  echo "‚úÖ Successfully added $count items"
}
```

### Progress Tracking
```bash
# Track work item progress across systems
track_todo_progress() {
  local sync_file="${HOME}/.claude/cache/todo-sync.json"
  
  # Initialize sync file
  if [[ ! -f "$sync_file" ]]; then
    echo '{"synced_items": {}, "last_sync": null}' > "$sync_file"
  fi
  
  # Collect progress from all systems
  local progress='{"items": []}'
  
  # From Taskwarrior
  if command -v task &>/dev/null; then
    local tw_progress=$(task project:work export | jq '
      map(select(.description | test("\\[.*#[0-9]+\\]"))) |
      map({
        number: (.description | capture("#(?<n>[0-9]+)") | .n),
        status: (if .status == "completed" then "done" else .status end),
        system: "taskwarrior"
      })
    ')
    progress=$(echo "$progress" | jq --argjson tw "$tw_progress" '.items += $tw')
  fi
  
  # From todo.txt
  if [[ -f "${HOME}/todo.txt" ]]; then
    local todotxt_progress=$(parse_todotxt_work | jq '
      map({
        number: .number,
        status: "pending",
        system: "todotxt"
      })
    ')
    progress=$(echo "$progress" | jq --argjson tt "$todotxt_progress" '.items += $tt')
  fi
  
  # Update sync file
  echo "$progress" | jq '{
    synced_items: (.items | group_by(.number) | map({key: .[0].number, value: .}) | from_entries),
    last_sync: (now | strftime("%Y-%m-%dT%H:%M:%SZ"))
  }' > "$sync_file"
  
  echo "$progress"
}
```

### Conflict Resolution
```bash
# Resolve conflicts between TODO systems
resolve_todo_conflicts() {
  local sync_file="${HOME}/.claude/cache/todo-sync.json"
  
  if [[ ! -f "$sync_file" ]]; then
    return 0
  fi
  
  # Find items with conflicting statuses
  jq '.synced_items | to_entries | map(select(.value | length > 1))' "$sync_file" | \
  jq -r '.[] | 
    .key as $number |
    .value as $statuses |
    if ($statuses | map(.status) | unique | length) > 1 then
      {
        number: $number,
        conflicts: $statuses
      }
    else empty end
  ' | while read -r conflict; do
    echo "‚ö†Ô∏è  Conflict detected for item #$(echo "$conflict" | jq -r .number)"
    echo "$conflict" | jq -r '.conflicts[] | "  - \(.system): \(.status)"'
    
    # Resolve by most recent update or priority system
    # For now, just log conflicts
  done
}
```

## Configuration

### Settings Management
```bash
# Load TODO integration settings
load_todo_settings() {
  local config_file="${HOME}/.claude/settings/todo-integration.yaml"
  
  if [[ -f "$config_file" ]]; then
    yq eval -o=json "$config_file"
  else
    # Default configuration
    cat <<'EOF'
{
  "enabled": true,
  "primary_system": "auto",
  "sync_systems": ["claude", "local"],
  "auto_sync": true,
  "sync_interval": "15m",
  "conflict_resolution": "most_recent",
  "calendar_integration": true,
  "notifications": {
    "on_add": false,
    "on_complete": true
  }
}
EOF
  fi
}

# Save TODO preferences
save_todo_preferences() {
  local prefs="$1"
  local config_file="${HOME}/.claude/settings/todo-integration.yaml"
  
  mkdir -p "$(dirname "$config_file")"
  echo "$prefs" | yq eval -P - > "$config_file"
}
```

## Main Integration Function

```bash
# Main TODO integration
integrate_todos() {
  local items="$1"
  local action="${2:-add}"  # add, sync, status
  local options="${3:-{}}"
  
  local settings=$(load_todo_settings)
  
  if [[ $(echo "$settings" | jq -r '.enabled') != "true" ]]; then
    echo "TODO integration is disabled"
    return 0
  fi
  
  case "$action" in
    "add")
      batch_add_to_todos "$items" "$(echo "$settings" | jq -r '.sync_systems | join(" ")')"
      ;;
      
    "sync")
      echo "üîÑ Syncing TODO systems..."
      track_todo_progress
      resolve_todo_conflicts
      ;;
      
    "status")
      local progress=$(track_todo_progress)
      echo "üìä TODO Status Summary:"
      echo "$progress" | jq -r '
        .items | group_by(.system) | 
        map({system: .[0].system, count: length}) |
        .[] | "  \(.system): \(.count) items"
      '
      ;;
      
    *)
      echo "Unknown action: $action"
      return 1
      ;;
  esac
}
```

## Examples

### Add Selected Work to TODOs
```bash
# Add work items after selection
add_selected_work() {
  local selected_items="$1"
  integrate_todos "$selected_items" "add"
}
```

### Sync TODO Status
```bash
# Regular sync job
sync_todo_status() {
  integrate_todos "" "sync"
}
```

### Check TODO Progress
```bash
# View current status
check_todo_status() {
  integrate_todos "" "status"
}
```